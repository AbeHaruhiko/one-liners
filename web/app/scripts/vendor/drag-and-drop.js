// Generated by CoffeeScript 1.4.0
/*
Copyright (C) 2011 Jacob Beard
Released under GNU LGPL, read the file 'COPYING' and 'COPYING.LESSER' for more information
*/

var svgDrag;

svgDrag = (function() {
  var getBBoxInCanvasSpace, getBoundingBoxInArbitrarySpace, svgNS, translate;
  svgNS = "http://www.w3.org/2000/svg";
  translate = function(element, dx, dy) {
    var m, newM, t, tl;
    tl = element.transform.baseVal;
    t = tl.numberOfItems ? tl.getItem(0) : element.ownerSVGElement.createSVGTransform();
    m = t.matrix;
    newM = element.ownerSVGElement.createSVGMatrix().translate(dx, dy).multiply(m);
    t.setMatrix(newM);
    return tl.initialize(t);
  };
  getBoundingBoxInArbitrarySpace = function(element, mat) {
    var bbox, cPt, calc, maxX, maxY, minX, minY, svgRoot, xs, ys;
    svgRoot = element.ownerSVGElement;
    bbox = element.getBBox();
    xs = [];
    ys = [];
    calc = function() {
      var cPtTr;
      cPtTr = cPt.matrixTransform(mat);
      xs.push(cPtTr.x);
      return ys.push(cPtTr.y);
    };
    cPt = svgRoot.createSVGPoint();
    cPt.x = bbox.x;
    cPt.y = bbox.y;
    calc();
    cPt.x += bbox.width;
    calc();
    cPt.y += bbox.height;
    calc();
    cPt.x -= bbox.width;
    calc();
    minX = Math.min.apply(this, xs);
    minY = Math.min.apply(this, ys);
    maxX = Math.max.apply(this, xs);
    maxY = Math.max.apply(this, ys);
    return {
      "x": minX,
      "y": minY,
      "width": maxX - minX,
      "height": maxY - minY
    };
  };
  getBBoxInCanvasSpace = function(element) {
    return getBoundingBoxInArbitrarySpace(element, element.getTransformToElement(element.ownerSVGElement));
  };
  return {
    setupCanvasForDragging: function(svg, dragSimpleRect) {
      var currentDraggingEntity, draggingRect, evtStamp, hideDraggingRect, isDragging, showDraggingRect, startEvtStamp;
      if (svg == null) {
        svg = document.documentElement;
      }
      isDragging = false;
      evtStamp = startEvtStamp = currentDraggingEntity = null;
      showDraggingRect = function(bbox) {
        if (bbox) {
          draggingRect.setAttributeNS(null, "x", bbox.x);
          draggingRect.setAttributeNS(null, "y", bbox.y);
          draggingRect.setAttributeNS(null, "width", bbox.width);
          draggingRect.setAttributeNS(null, "height", bbox.height);
        }
        return draggingRect.removeAttributeNS(null, "display");
      };
      hideDraggingRect = function() {
        return draggingRect.setAttributeNS(null, "display", "none");
      };
      if (dragSimpleRect) {
        draggingRect = document.createElementNS(svgNS, "rect");
        draggingRect.setAttributeNS(null, "class", "simple-dragging-rect");
        hideDraggingRect();
        svg.appendChild(draggingRect);
      }
      svg.addEventListener("mousemove", function(e) {
        var tDeltaX, tDeltaY, toDrag;
        e.preventDefault();
        if (isDragging) {
          tDeltaX = e.clientX - evtStamp.clientX;
          tDeltaY = e.clientY - evtStamp.clientY;
          toDrag = dragSimpleRect ? draggingRect : currentDraggingEntity;
          translate(toDrag, tDeltaX, tDeltaY);
          return evtStamp = e;
        }
      }, false);
      svg.addEventListener("mouseup", function(e) {
        var tDeltaX, tDeltaY;
        e.preventDefault();
        if (isDragging) {
          isDragging = false;
          tDeltaX = e.clientX - startEvtStamp.clientX;
          tDeltaY = e.clientY - startEvtStamp.clientY;
          if (dragSimpleRect) {
            hideDraggingRect();
            translate(currentDraggingEntity, tDeltaX, tDeltaY);
            return draggingRect.removeAttributeNS(null, "transform");
          }

          // mayuge customize
          if (tDeltaX != 0 || tDeltaY != 0) {
            var $scope = angular.element('#content').scope();
            $scope.export2canvas();
            // if ($scope.conf.autoSave) {
            //   $scope.savePNG();
            // }
          }
          // mayuge customize

        }
      }, false);
      return function(element) {
        return element.addEventListener("mousedown", function(e) {
          var bbox;
          e.preventDefault();
          e.stopPropagation();
          isDragging = true;
          currentDraggingEntity = element;
          if (dragSimpleRect) {
            bbox = getBBoxInCanvasSpace(currentDraggingEntity);
            showDraggingRect(bbox);
          }
          return startEvtStamp = evtStamp = e;
        }, false);
      };
    }
  };
})();
